## SINOF：动态二进制翻译的静态优化架构研究

### 1. 动态二进制翻译中的优化技术

常见的动态优化技术有热路径优化，硬件辅助优化等。

#### 1.1. 动态二进制翻译中的 Profiling

在传统方法中，代码的 Profiling 给编译程序提供反馈信息，整个过程处于程序员的控制之下。编译器首先将源程序分解成控制流图，然后在分析的过程中插入探测器产生插桩代码(Instrumented Code)收集 Profile 信息。探测器是一段代码序列，用来收集程序执行的信息，这些信息被保存在 Profile 日志文件中。

由于动态二进制翻译器中的 Profiling的实时性，因此不可能采用过于复杂的算法。一般的动态二进制翻译器都采用**热路径预测**的方法，即先运行程序一段时间，收集在这段时间内代码重复执行的情况，然后在此基础上做出预测。

#### 1.2. 热路径识别策略

在动态二进制翻译中，常见的热路径识别方法有三种：

- 基于基本块 Profile 信息的热路径识别：每次**遇到条件跳转时**就简单地比较两个目标块执行的次数，并把**执行次数较多**的那个块作为热路径上的下一个基本块;
- **基于边** **Profile** **信息的热路径识别**（这个方法很有效）：不去收集基本块被执行的次数，而是记录了基本块之间的跳转次数。
- 基于路径 Profile 信息的热路径识别：为每条从循环入口到出口的边建立一个档案，记录每条路径被执行的次数。
- NET 动态热路径预测策略：路径被分为路径头和路径尾两部分，路径头是指路径的起始点，路径尾则指剩下的部分。Dynamo 通过仅对路径头进行 Profiling 而预测路径尾来降低 Profiling 的开销。这种策略的出发点是一个热的路径头意味着程序正执行于热区域，而紧接其后执行的路径则很有可能在那个区域中（不懂）。

#### 1.3. 超级块的生成策略

超级块的组成元素是热路径上的基本块，但是超级块的代码物理上是连续的，这种连续性增加了代码的本地性(Code Locality)，从而增加了硬件 Cache 的命中率，避免了程序从超级块内跳出引发的上下文切换开销。同时超级块的平均代码数量远远大于基本块的代码数量，代码数量更多意味着优化潜力更大。

#### 1.4. 动态优化技术的不足

- ​	优化结果无法持久化：每一次程序执行时，都会进行新一轮的优化，而每次的优化结果在程序执行完成时都将被丢弃。
- ​	难以进行全局性优化：动态优化过程无法收集到用于全局优化的信息。
- ​	采用简化的 Profiling 技术：考虑到 Profiling 过程带来的性能开销，动态优化过程必须较简化的 Profile信息收集算法，从而无法支持较为复杂的优化算法。



### 2. 动态二进制翻译的静态优化架构实现

静态优化过程可大致分为两个步骤：首先，对源二进制代码进行分析，获取程序的全局和局部信息：然后，根据所得到的信息，在代码翻译过程中进行优化和调整。

文章介绍了一种适合于动态二进制翻译的动静结合的优化架构(Sinof, Static-integrated Optimization Framework for Dynamic Binary Translation)。其整个工作流程如图所示，主要分为三个阶段进行，包括：

- ​	信息收集：程序首次运行时，Sinof 在翻译执行程序的同时，运用 Profiling 技术对程序进行信息收集，等程序运行完成后，将 Profile 信息和翻译获得的目标代码持久化为文件。
- ​	静态分析：静态分析工具会根据 Profile 信息，对目标代码进行某些优化，并将优化的目标代码持久化为文件。
- ​	代码加载：在程序之后执行时，将优化代码的目标代码和源程序镜像一起加载，依靠代码优化的效果获得执行性能的提升。

![img](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/5.1.png?raw=true)  

#### 2.1. 信息收集阶段(Collecting Information)

为获得较完整的程序动态信息，在信息获取阶段 Sinof 会将部分动态优化功能关闭，其中包括动态构建超级块等。同时，因为首次执行时，Sinof 的**关注重点并非程序执行性能**，可以采用较为复杂的 Profiling 技术，**获得足够丰富的动态信息**，以支撑随后的离线优化。这里采用的是基于边 Profile 信息的热路径识别技术。

#### 2.2. 静态分析阶段(Static Analysis)

整个静态分析阶段都将根据上一阶段所获得的 Profile 信息在**离线方式**（离线方式到底是怎样执行，多线程不失为一种好方法）下对目标代码进行优化。

（1）热路径的识别。

根据各个基本块的 Profile 信息统计每个基本块总的执行次数，并根据统计值由高至低将基本块信息(TB_Save)对象排序。然后，热路径识别过程从最热的基本块开始，根据边之间关系的 Profile 信息遍历 TB_Save 对象，直到遍历完所以的 TB_Save 对象。这样将产生若干对象序列组，每个序列都是一条热路径。

（2）目标代码调整。

- 代码块位置重置。根据每个 TB_Save 对象在序列组中的次序，将对应的目标代码块逐个复制到静态分析器提供的缓存中，使每个块的物理位置连续。
- **跳转的处理**（重要，若有需要可以实现）。按照代码块中跳转类型，将X86后端产生的目标代码块分为四种不同的类型：直接无条件跳转、直接条件跳转、间接无条件跳转和间接条件跳转。在静态分析后，根据热路径对代码块进行了位置重置，因此，可以利用每条热路径中块与块之间物理位置的连续性，减少大量的跳转，大幅提高性能。
- 重定位信息修正。在完成跳转处理和相关的指令添删后，原来的重定位信息中块偏移量已不再正确，与需重定位的指令产生了偏差。

（3）静态实现链接。

（4）相对地址回填

#### 2.3. 代码加载阶段(Loading Code)

在静态完成目标代码优化后，当程序再次运行时，源程序镜像和优化代码将同时被加载。翻译器将直接将优化代码插入目标代码缓存(TCache，Target Code Cache)中。翻译器会先根据当前基本块的源机器地址(SPC)在 TCache中查找是否此块被翻译过，如果找到对应的目标块，就优先执行现有的目标块。因此，静态优化过的代码块将优先得到执行，系统的执行性能也就得到相应的提升。

### **3. 思考**

3.1. xqm中有动静结合的翻译策略么，如果没有要怎么实现呢？

3.2. xqm中的code_cache管理是怎样的。 Cpu-exec.c：486 tb = tb_lookup__cpu_state(cpu, &pc, &cs_base, &flags, cf_mask);

3.3. xqm中有profiling么，没有要怎么实现？有，但还不知道怎么利用。