## 动态二进制翻译优化研究

### 1. 标志位处理优化——EfLA 算法

拥有标志寄存器的处理器中，绝大多数指令都会对多个标志位进行修改，而在没有标志位寄存器的ISA中翻译标志位非常麻烦，那么如果完全把标志位翻译出来，而这些定值并没有被使用的话，浪费就显而易见了。所以，对于标志位进行定值引用分析，删除冗余计算，对提高翻译系统性能是非常重要的。

#### 1.1. 相关工作

（1）Fx!32是一个动静结合的翻译系统，结合了解释执行和静态翻译两种模式。对于静态翻译，采用了**数据流分析**的方法，基本上可以完全消除标志位的冗余计算，但是数据流分析本身开销比较大，不过这个过程是在静态时进行，不会影响到运行时性能。动态执行需要解释器支持，解释器采用了**延迟计算**的方法，即对于每条指令把需要用到计算标志位的信息(包括操作数，操作码等信息)先存起来，而不是马上计算标志位，等到需要使用到标志位的时候再通过原先存储的标志位信息计算标志位。

（2）Intel 的 IA32 EL构建**不完全数据流图，**一般包含 1-20 个基本块，在不完全流图上进行数据流分析。流图内部基本可以消除冗余计算，但是到了基本块边界，就会产生冗余计算。部分流图数据流分析时，开销会比完全流图的分析小，但是个别情况效果会略差，例如边界情况没法分析，就会有可能比完全流图产生更多的冗余计算。

（3）Transmeta 公司开发的 Crusoe 芯片，采用了**硬件支持标志位**的方法，即它也设置了一个类似 x86 的标志寄存器，可以把每个指令的标志位影响记录下来。 该系统采用硬件实现标志位计算，可以实时把每一条指令对标志位的影响都记录下来而不会影响执行速度。

#### 1.2. EfLA 算法

定值(def)：指令对某一个标志位进行赋值，称该指令对标志位定值。

引用(use)：指令使用某一个标志位的值，称该指令对标志位引用。

指令对标志位无影响：指令对某一个标志位既不引用，也不定值，称该指令对标志位无影响。

（1）算法设计

标志位分析的理想目标，就是把所有的无用定值全都找出来。而后在翻译指令的时候，不必理会这些无用定值，仅需对于活跃定值进行翻译。

基本块内使用**线性算法**分析标志位定值引用关系，一次扫描就可以得出标志位的活跃注销信息，开销非常小。对于边界的处理，把所有后继基本块对标志位的影响转化成一条**虚拟指令**，附加在当前基本块中，该虚拟指令只对分析标志位定值引用有效。

### 2. 应用级的异常处理优化

异常处理，通常需要**回退**(roll back)机制，即在发生异常之后，能够把在产生异常之前的机器状态还原出来，机器状态主要指 cpu 的状态(包括通用寄存器以及一些控制、状态寄存器)以及内存的状态。

#### 2.1. 背景介绍

应用程序级翻译，按照对库函数是否翻译，有两种翻译层面：对库函数的包装和对系统调用的包装。如果翻译器是对库函数进行包装，那么在翻译中碰到库函数，就不对库函数本身进行翻译了，而是用相同功能的本地库函数进行替代。翻译器对系统调用的包装，则比库函数包装更加底层，即遇到库函数时，将进行库函数的翻译，只有碰到了系统调用，才用功能相同的系统调用进行模拟。

#### 2.2. 相关工作

（1）DAISY 中使用的方法，对于乱序指令，在将结果放入寄存器之前先放入非物理(non-architected)的寄存器中，然后在原来的顺序点(即指令调度之前该指令的位置)插入拷贝指令把非物理的寄存器放到物理的寄存器中。

（2）在进入 trace 之前，把所有的寄存器内容都拷贝到备份寄存器中。这样，计算结果就直接放入映射的寄存器中。一旦 trace 上发生异常，所有的备份寄存器都还原到真正映射的寄存器中，然后从 trace 头开始解释执行 trace。

（3）在 trace 转化的边界保持精确的检测点(precise checkpoint)，当发生异常的时候，可以回溯到最近的一个检测点。

#### 2.3. 信号 Signal 异常的处理

信号 Signal 异常是类 unix 系统最普遍的异常，操作系统提供了一个库函数调用实现信号机制，该库函数 signal 的函数原型为 void (*signal(int signum, void (*sighandler)(int)))(int)，signum 为信号的值，sighandler 为异常处理函数指针，当硬件产生异常信号，如果这个信号已经被signal 函数注册过，那么就将会执行 sighandler 函数。

**绝大多数情况下** **sighandler** **不会访问机器状态**，那么我们在翻译前通过分析发现该signandler不会访问机器状态，那么就不需要保留机器状态。为了处理少数使用异常之前机器状态的特例，算法需要加上分析 sighandler，一旦发现 sighandler 中调用了读取机器状态的库函数，或者在对机器状态没有定值之前就已经引用，那么就必须在翻译系统中加入机器状态的保存，确保异常处理程序中得到准确的机器状态。

### 3. 寄存器分配优化技术

把临时寄存器分为两类：指令内寄存器和跨指令寄存器。指令内寄存器是指翻译指令临时产生的变量，活跃区间就在翻译这条指令之内。跨指令寄存器指翻译指令产生的变量，活跃区间跨越了该条指令翻译范围。

算法用到的主要数据结构以及部分变量名称。

（1）MAX_REG_NUM：可用于寄存器分配的寄存器个数;

（2）MAX_DIS_REG_NUM：被禁用的寄存器的最大数目;

（3）reg_allocate_array：可分配寄存器列表，总共有 MAX_REG_NUM 项，数组的每一项都有两个元素，一个是表示被禁用的寄存器的布尔型变量 disable，指明当前寄存器是用于活跃区间跨越单条指令的变量，另一个元素 serial_num 表明被分配的物理寄存器序号;

为一个操作数 ir2_operand 申请一个寄存器，如果有可用物理寄存器，就**扫描一遍可分配寄存器数组reg_allocate_array分配一个物理寄存器**，否则 spill 该变量。寄存器分配的整体开销和程序块中包含的指令数量成正比，算法的复杂度为 O(N)，N 为指令条数。

### 4. 思考

（1）xqm的寄存器分配算法。