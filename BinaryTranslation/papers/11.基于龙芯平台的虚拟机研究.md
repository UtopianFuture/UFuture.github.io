## 基于龙芯平台的虚拟机研究

### 1. 二进制翻译相关工作

#### 1.1. FX!32：基于度量的离线优化

首先解释执行，同时收集profile，用于静态优化。之后的执行会部分使用经过优化的代码，部分继续解释执行，同时继续生成profile。通过这个迭代过程，执行速度会越来越快。不适用于处理系统级虚拟机。

#### 1.2. UQBT和UQDBT：二进制翻译的编译器视角

翻译器引用了两个术语：RTL(Register transfer list，寄存器传输列表)，表示指令对寄存器的影响；HRTL(High Level Register transfer Language，高级寄存器传输语言)，机器无关语言，描述一种虚拟的高级机器。

target的可执行文件首先转化成target-RTL，传输到分析器，在分析器中生成HRTL，再将HRTL转换成对应的host-RTL，host-RTL传输到编码器，编译成host的可执行文件。

UQBT是静态翻译器，UQDBT是相应的动态翻译器。

#### 1.3. DAISY和BOA：VLIW指令集上的协同设计

DAISY：当新的指令第一次在DAISY上执行时，这些指令被翻译成VLIW元语，这些元语是并行的，存储在target os不可见的内存区域。翻译、存储过程都是有VMM控制的。之后执行这些指令时就不需要重新翻译。

DAISY能够处理的问题有：自修改代码，精确异常，乱序内存访问，多核一致性，I/O映射。

BOA：BOA是通过用软件二进制翻译来实现高频率的处理器。用二进制翻译能够降低硬件设计的复杂度。它的翻译策略就是先是对单一路径（我的理解是没有条件跳转）正常的解释执行，当执行次数超过15次（或某个比例）就将这一路径的代码编译成PowerPC的代码组，然后翻译成BOA指令组。BOA也运用了代码块的思想。当然在解释执行期间也会收集profile，用于分支预测等等。

因为BOA是乱序执行，对于指令执行的调度采用贪心的原则，即当如下条件满足是执行该指令：

（1）所有的操作数都可用；

（2）用空闲的执行单元；

（3）用可用的寄存器存放数据。

#### 1.4. Crusoe处理器和CMS：协同设计处理器及配套软件

Transmeta公司的Crusoe处理器是一款协同设计处理器，用于在VLIW机器上运行X86软件。其硬件部分是Crusoe处理器，软件部分是动态二进制翻译器CMS(Code Morphing Software)。

CMS的结构总体上可以分为两部分：interpreter和translator。初始化之后，interpreter对x86的指令进行解码和执行（解释执行），同时收集执行频率，分支跳转目标，I/O操作等数据。当x86指令块的执行频率达到某个临界点时，这一指令块就移交给translator，translator对其进行翻译并将结果保存到translation code中，之后除非遇到无效这一指令块的指令，否则都是执行translation code中的指令。同时translation code中还会进行链(chaining)操作，即构建超级块，减少上下文切换。当遇到fault时，就用commit-rollback机制进行恢复。这一机制与体系结构中的reorder buffer(ROB)和reservations station类似。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/11.1.png?raw=true)  


#### 1.5. Dynamo：用于优化的二进制翻译器

Dynamo是可以和静态编译技术结合的动态优化系统，能够提升本地代码的执行性能。由于Dynamo是在程序执行时运行的，为了不影响执行效率，所以只优化指令流中识别出来的“hot”指令序列，并将优化后的指令块(fragment)存到fragment cache中。而有效优化的基础是程序的性能主要受小部分指令影响。Dynamo认为具有两个部分具有优化潜力：间接/直接跳转和code cache。

对于第一点，Dynamo首先利用MRET (*for most recently executed tail*)算法识别出“热”代码，然后移除冗余的直接跳转和部分间接跳转，还有一些间接跳转转化为直接跳转，同时利用块链技术减少上下文转换。

对于第二点，Dynamo尽量只保存当前工作集的代码，而当发现大量的fragment被创建，这意味着工作集的变化，就提前更新fragment cache。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/11.2.png?raw=true)  


#### 1.6. IA-32EL：Intel官方模拟X86的二进制翻译器

这个翻译器还没有了解。

### 2. 二进制翻译的优化思路

针对二进制翻译翻译-执行-查找的执行过程，能够优化的有如下几个方面：

- 在翻译阶段，优化工作的主要关注点是**如果生成更加优秀的二进制代码**。常用基于数据流分析的优化策略，如常量传播、常量折叠、复写传播等。还可以调用主机的为二进制翻译设计的指令来进行优化，这是软硬结合的方法。
- 在执行阶段，最重要的优化是超级块，它能减少上下文切换，提高系统效率。生成的超级块也能进一步优化。
- 在查找阶段，重点是减少查找时间和查找失败的次数。应该设计适合的散列算法提升查找速度，应用内联缓存等方法提高查找命中率。也可以使用CAM等硬件来加速。

另一个需要注意的问题是，所有的优化方法都应该使用量化的研究方法加以验证。一般来说，优化应该遵循阿姆达尔定律(Amdahl’s Law)，让最常见的情况更快。

#### 2.1. T-Cache查找优化

#### 2.2. T-Cache替换策略

#### 2.3. 间接跳转优化

对于直接跳转，采用（连）块（成）链方式处理，对于间接跳转，使用添加缓存预测的思想来优化。

#### 2.4. 基本块优化

内部代码优化，生成高质量的代码。

#### 2.5. 寄存器映射

单做寄存器一致性映射对于整个性能提升不大，而应将其和其他优化方法结合。

#### 2.6. 超级块优化

### 3. 跨ISA多核虚拟处理器

在多核虚拟处理器的实现中，需要考虑的两个核心问题是：原子指令的模拟和虚拟中断的模拟。