## 基于龙芯平台的二进制指令翻译系统的设计与实现

### 1. 国内外相关研究

1. FX！32：x86指令动态翻译为alpha架构。

2. QEMU已经支持x86架构了。

   ![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/1.1.png?raw=true)

3. Digital Bridge模拟器：X86 指令集向 MIPS 指令集的转化（如果有这个还有我们什么事阿)。

# 2. QEMU 运行机制

整个QEMU系统由：控制核心、TCG(Tiny Code Generator)和执行模块三大部分组成。QEMU会将读取到的可执行文件（怎样读取？）通过前端编码器翻译成TCG指令（前端编码器是啥），形成相应的中间代码；其次通过后端编码器，将TCG指令翻译成目标平台的可执行代码。其使用 TCG 指令(中间代码)将宿主平台和目标平台两个部分连接，这样做提高了 QEMU 翻译的通用性，但也会影响相应的翻译效率。QEMU 以一个代码块为基本单元,代码块以分支、跳转等指令做为分隔。完成翻译的代码块会存储在内存中等待被调用执行，同时 QEMU 会记录已经翻译的代码块,方便后续直接使用。

# 3. 翻译系统整体架构设计

## 3.1 系统整体架构介绍

二进制指令翻译系统的核心功能是指令翻译系统,其部分外围管理,如二进制程序 (ELF) 读取等交由 QEMU 统一管理；核心部分，如指令翻译及优化等用自主开发target_X64_to_mips_host(下简称 XTM)进行管理。

## 3.2 系统程序功能模块划分

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/1.2.png?raw=true)

系统主要分为以下三个部分：

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/1.3.png?raw=true)

### 3.2.1 代码存储管理系统：

代码存储管理系统主要用于目标平台二进制数据和生成代码块的管理调度等。其中指令区管理负责管理目标平台的二进制代码；反汇编数据管理部分负责管理从目标二进制代码生成的反汇编代码；代码块管理负责管理生成的代码块数据。

### 3.2.2 指令翻译系统：

指令翻译系统是整个二进制翻译系统的核心,主要功能是将目标二进制代码翻译成宿主机二进制代码,同时对翻译的代码进行部分优化。该系统由以下5大部分组成：目标代码反汇编器、指令翻译器、宿主代码汇编器、代码优化器和硬件模拟器五大模块组成。其中硬件模拟器功能是模拟相应的硬件功能,包括了模拟 CPU、内存、总线和外设等。

### 3.2.3 指令管理系统：

执行管理系统用于控制整个翻译系统的翻译、运行等。该部分含有上下文切换、指令调用处理以及异常中断处理三个模块。上下文切换模块负责翻译系统的上下文切换。当一个代码块完成翻译后，翻译系统通过上下文切换的方式，将控制权移交给代码块，完成相应指令的运行。指令调用处理模块负责代码块间、上下文切换等跳转地址的管理。在指令完成翻译后上下文切换前，该模块通过在翻译完成的代码块后插入跳转指令，使代码块执行完成后能回到上文断点处；在翻译部件完成一个代码块翻译后，该模块还负责查找链接下一个代码块，生成跳转指令，移交上下文切换模块负责运行。异常中断处理模块负责二进制指令产生的异常以及中断的处理。

# 4. 二进制翻译流程

## 4.1指令翻译流程

指令翻译流程主要划分成三步，从目标机二进制指令到程序可识别的 ir1 指令的反汇编过程；和从 ir1 到宿主平台临时指令 ir2 的翻译过程；以及从 ir2 到宿主平台二进制指令的汇编过程。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/1.4.png?raw=true)


### 4.1.1 宿主机二进制指令到 ir1

这部分通过使用capstone作为反汇编器，调用capstone的API完成反汇编，输出结构体。

### 4.1.2 ir1 到 ir2

二进制翻译动作采取逐条翻译的方式，即每次针对一条 X64 指令，生成对应的 MIPS 临时代码 ir2。翻译过程中会通过判断指令码，使用相应的翻译函数执行翻译。此时的翻译是以单条 X64指令为单位的，在完成一条指令翻译后，会继续寻找下一条指令翻译，直到完成ir1 TB 的全部翻译工作，形成 ir2 TB。这个ir2 TB应该就是一段临时指令。

### 4.1.3 ir2 到目标平台二进制指

完成 ir1 TB 的翻译形成 ir2 TB 后,翻译系统会调用汇编器进行汇编。汇编完成的代码将会装入内存中划分的一块宿主平台二进制代码区 gen_code_buf 。所有翻译完成的二进制代码将会存储在这里等待被上下文切换后执行。在 ir2 TB 的所有指令完成汇编动作后,目标平台二进制代码区就会形成宿主平台的二进制代码块 (Native Code Block)。

## 4.2 翻译种类划分

指令翻译器包含9大指令。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/1.5.png?raw=true)


# 5. 二进制翻译系统详细设计与实现

## 5.1 代码存储管理系统

### 5.1.1 指令区管理

指令区管理由 QEMU 负责，QEMU 首先会读取二进制文件头（应该看一下是怎么取的），判断 ELF 头信息正确后，会对相应段进行初始化。初始化完成后，二进制文件指令及数据会被装入内存相应段中，从 ELF 头标明的程序入口处取第一条指令，调用翻译器进行翻译（这个和之前看的没有区别）。

### 5.1.2 反汇编数据管理

反汇编数据管理由XTM负责，为了便于之后的优化，在此还加入了哈希索引，使用 qht(QEMU hash table) 组件，通过 TB 首条指令的 PC 值，去索引整个反汇编数据链表（应该是便于查找）。

### 5.1.3 代码块管理

代码块管理也分成代码块的管理和生成的目标平台代码块的管理。

ir2 代码块的管理由 XTM 负责，在 ir1 TB 向 ir2 TB 翻译过程中，XTM 会记录每条指令翻译出的 MIPS 指令数量，并且将翻译形成的数据块 (ir2 TB) 保存在链表中，方便后续执行汇编时调用。

生成的目标平台代码块由 QEMU 和 XTM 共同管理。代码块存储区会由 QEMU初始化，分配一块连续的内存空间 (code_gen_buffer，所有翻译好的宿主可执行文件)，并记录内存起始地址。在完成翻译后，XTM 会获取当前代码块存储区可用空间起始地址 code_gen_ptr，将翻译完成的二进制数据存入，并将可用空间起始地址游标向后移动。同时会在 TB 数据结构中记录翻译完成二进制代码起始地址，标注为 tc_ptr。

## 5.2 指令翻译系统

### 5.2.1 宿主代码汇编器