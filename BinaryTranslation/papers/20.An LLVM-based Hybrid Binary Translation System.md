## An LLVM-based Hybrid Binary Translation System

### 1. Abstract

SBT has **the code discovery** and **the code location** problems caused by indirect branches make SBT systems hard to develop. This paper presents **a hybrid binary translation (HBT) system** which leverages the LLVM infrastructure to translate source binary code, optimize, and generate target binary code.

LLVM is an open source compiler framework which can convert machine-independent instructions to machine-dependent assembly code.

### 2. Overview

This translator **uses** **LLVM API** to read a source binary file, disassemble instructions and translate them into LLVM instructions.

The flow of execution, and dynamic translation, shown in Figure below, consists of two parts. The first part is to execute statically translated code. The second part is dynamic translation.

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/20.1.png?raw=true)  


If the instruction under execution is an indirect branch, the address mapping table is consulted to find the corresponding address in the target binary. Execution continues from that address.

If the address mapping table **does not contain an entry for the destination** of the indirect branch instruction, it will **switch to the dynamic translator** and looks up the destination of the indirect branch instruction in the code cache. **If found**, the translated code in the code cache is executed directly. Otherwise, if the destination has not been translated yet, The dynamic translator will find the destination in the source image, **translate source instructions**, put the translated code in the code cache, and execute the translated code.

### 3. Implementation

For the performance reason, the text, data, and BSS sections of the original ARM binary are copied to the target binary **at the same address**. Therefore, we do not have to do the address remapping for memory access while program execution.

#### 3.1. Hybrid Translation

The dynamic translator is implemented as a library and is linked with target binaries.

#### 3.2. Indirect Branch Handling

For some indirect branch instructions whose destinations cannot be determined during static time, we use **an address mapping table** or **dynamic translation** to resolve the destinations. The address mapping table maps an address in the source image to the corresponding address in the target binary.

#### 3.3. Register Mapping

In this translator, each register of the source ISA is mapped to **an LLVM global variable**. if we want to share these registers between the statically-translated binary and the native code generated by the dynamic translator, the variables needs to be visible by the dynamic translator. As a result, we use **two sets of global variables** for simulating ARM registers. One is for the statically translated binary only, the other is for the dynamic translator only. When switching between the dynamic translator and the statically-translated binary, **a context switching between these two sets of variables** needs to be performed.

#### 3.4. Finding Indirect Branch Addresses

The easiest way to avoid switching to the dynamic translator is to include all source instruction addresses in the address mapping table.

#### 3.5. Block Chaining

In dynamic translation, switching between the run-time system and the dynamically translated blocks (abbreviated as dt blocks) causes significant overhead.

### 思考：

HBT与SINOF动静结合的思路大不相同。

HBT中主要是静态翻译（利用LLVM），翻译后的代码直接保存之后执行，在执行时如果遇到分支指令，如果在地址映射表中存在目的地址条目，则直接跳转；如果不存在，就会切换到动态翻译器中，在动态翻译器的code cache中寻找该代码块，如果找到，则直接执行，如果没有找到，则由动态翻译器翻译后执行。

而SINOF中主要是动态翻译，在动态翻译执行时进行profile，利用这些收集到的信息进行离线优化，优化方式有热路径识别和超级块等。将优化后的代码块保存到code cache中，之后就直接执行这些代码块。多次优化后性能逐渐变好。