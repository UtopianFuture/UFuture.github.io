## 内核级二进制翻译系统设计及性能优化

### 1. 一些背景知识

（1）龙芯动态二进制翻译系统也是基于QEMU开发的。

（2）动态二进制翻译系统的目标程序可能会用到一些硬件设备的功能这就需要外设模拟器来提供相应的硬件设备模拟功能。比如显卡、网卡等。

### 2. 动态二进制翻译面临的主要技术问题

（1）基本块索引。文章在充分挖掘cache性能的基础上，结合现代CPU设计中的核内内容索引全相连存储技术（Content Associated Memory, CAM），提出了一种软硬结合的分级虚拟机后端指令索引机制（Level based Instruction Index Strategy, LIIS）。

（2）分支跳转指令。

（3）寄存器分配。用内存模拟可移植性高，但性能低。在host的通用寄存器多于宿主平台时，为何不直接指定固定的物理寄存器代替target的寄存器。如在MIPS中的32个通用寄存器指定8个寄存器作为X86的8个通用寄存器（经过测试，这样性能反而不高）。

（4）内核驻留模块的翻译。即有些大型应用软件会用到OS内核驻留模块，如使用显卡驱动，声卡驱动等等。但传统的应用级翻译系统无法直接翻译执行OS内核中的模块，只有系统级翻译系统才能做到。文章设计了一种新的动态二进制翻译框架（User space translator and Kernel space translator Cooperate Framawork, UKCF）。UKCF有两个翻译器，一个工作在用户态，用来翻译用户态指令；另一个工作在内核态，用来翻译执行内核驻留模块的指令。

（5）实时性问题。

### 3. KBT二进制翻译系统

在面对上述第4个问题时，文章提出了一种新的翻译系统设计和优化方法，即将**二进制翻译系统从用户空间移入OS的内核空间**（这种构想很有趣，需要仔细琢磨，**KVM**就是这样），这样做除了能解决上述问题，还可以利用内核的特性、host的硬件性能，进一步优化翻译系统。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.1.png?raw=true)  

#### 3.1. KBT系统的整体结构设计

内核态动态二进制翻译系统KBT（Kernel Level Dynamic Binary Translation System）主要有5个功能模块：

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.2.png?raw=true)  

- 用户态监视器。加在运行于用户空间的target程序，并管理user space和kernel space的交互。
- 内核态监视器。为target程序内核驻留模块的直接翻译执行提供必要的接口。其作为host OS的内核模块，可以获得target程序内核驻留模块的代码和数据信息，从而可以直接引导和翻译内核驻留模块。
- **CPU**模拟器**。**模拟target CPU的执行环境（因为要执行target部分内核模块，可以理解为半系统虚拟机），并将需要翻译的指令传递给指令翻译器。其结构很复杂，相当于实现target OS的部分功能。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.3.png?raw=true)  


- 指令翻译器。将target指令翻译为host指令并保存。
- 外设模拟器。将target程序对硬件的操作传递给host的硬件。因为KBT本身是host内核的一部分，故可以直接操作底层硬件设备，借此优势可以提供一种新的硬件设备模拟方式，即管道式硬件设备模拟。该方法将应用程序中对硬件设备的操作通过内核中的“管道”直接传递给硬件设备。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.4.png?raw=true)  


### 4. KBT后端指令管理系统性能优化

在大多数应用中，DBT系统有超过20%的时间用于指令查找。已有的DBT系统都有简单的后端指令索引机制，如QEMU使用一段内存保存所有翻译后的指令块，所有翻译后的基本块组成一个哈希表，以基本块对应的首条目标平台指令的物理地址作为检索键值。QEMU中还有一个较小的指令cache用于支持快速查找。实际上是每个链最多只有一个节点的hash表。cache保存最近使用的基本块首地址。在针对一个指令地址查找基本块时，采用两级查找：首先在cache、其次在hash中查找，当设定的内存被翻译后的指令块填满后，将整段内存清空，并装入新的指令块。

#### 4.1. LIIS设计思想

LIIS策略也是**基于**cache**分级思想**。

#### 4.2. LIIS系统结构

LIIS系统具有三级指令存储结构。翻译系统首先将翻译出来的指令存入L3存储系统。L3存储系统位于内存，容量大，速度慢。对于其中高频执行的指令，将其放入cache中锁定的一个固定区域，即L2存储系统。其容量较小，速度较快。对于L2存储系统中最高频执行的指令，将他们的索引信息存入CAM（Content Associated Memory），实现了一种CAM索引的Cache指令存储系统（CAM Index Cache, CIC），CIC使CAM和Cache协同工作，能够单个CPU指令周期完成后端指令查找。CIC使用CAM的地址域存放基本块对应的目标代码PC值，对应的内容域存放基本块的首地址。

#### 4.3. L3替换算法

> i= pc & (L3_size – 1)

如果检测到i冲突，比较pc，如果pc相等，说明命中，如果不相等，则冲突，需要重新翻译并替换该块。

#### 4.4. L2替换算法

只保存运行1次以上的基本块，并优先替换未被CAM索引的基本块。

#### 4.5. L1替换算法

只保存执行2次以上的基本块，并从第一项开始循环替换。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.5.png?raw=true)  


### 5. KBT的内核模块翻译系统性能优化

有些大型应用软件会用到OS内核驻留模块，如使用显卡驱动，声卡驱动等等。但传统的应用级翻译系统无法直接翻译执行OS内核中的模块，只有系统级翻译系统才能做到（**这样理解对么**）。文章设计了一种新的动态二进制翻译框架（User space translator and Kernel space translator Cooperate Framawork, UKCF）。UKCF有两个翻译器，一个工作在用户态，用来翻译用户态指令；另一个工作在内核态，用来翻译执行内核驻留模块的指令。与传统的纯用户态翻译器翻译执行整个target OS相比，**UKCF**仅需要翻译执行内核驻留模块本身的指令，而操作系统的相关功能则通过外部函数直接执行机制交由host OS实现（不懂）。

#### 5.1. UKCF设计与实现

显卡驱动是嵌入在OS内核中的模块。当应用程序需要使用显卡驱动时，它首先调用OS内核API，陷入内核，然后调用显卡驱动的相关函数。在驱动执行过程中，可能会调用其他的OS函数，这就是外部函数调用。注意，这里使用显卡驱动是应用程序自带的，但是显卡驱动要在内核态才能执行，故一般的用户态翻译器就算翻译也执行不了，因为翻译器本身是运行在用户态的，就算翻译成可执行文件，执行的过程还是翻译器的一部分功能。那问题来了，如果程序没有自带驱动，但是要调用驱动怎么办，用host的驱动么？

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.6.png?raw=true)  


UKCF需要监控图中的两种调用关系，并进行执行模式的切换：

（1）从内核API到显卡驱动的函数调用。执行的指令流从host切换到target，因此UKCF需要截获调用的函数，并从堆栈中解析出函数的参数，然后翻译该函数。

（2）从显卡驱动到OS内核的函数调用。执行的指令流从target切换到host，因此UKCF需要切换到外部函数直接执行机制，直接执行OS内核中的函数。当函数执行完后，返回现场，重新开始翻译执行。

当内核API调用显卡驱动中的函数时，UKCF需要捕获被调用函数的地址作为开始翻译的入口地址。UKCF使用函数套壳（functions shell）技术截获该地址。显卡驱动在被加载入host OS内核的时候，需要将自己可能被外部调用的所有功能函数注册到内核中。为了截获显卡驱动中被调用函数的入口地址，UKCF对该函数进行加壳操作，并将加壳后的函数注册到OS内核中。在之后的运行中，当OS调用显卡驱动中的内核函数时，会调用对应的壳函数，壳函数会将原函数的地址返回给UKCF，UKCF保存上下文开始翻译执行。

当显卡驱动调用内核函数时，UKCF跳转监视器会检测到这个调用，UKCF保存上下文，将PC改为被调用函数的目标地址，开始执行。

UKCF执行框架包含6个功能模块：用户态翻译器、内核态翻译器、用户态CPU模拟器、内核态CPU模拟器、内核模块加壳器和跳转监视器。

其中用户态CPU模拟器时第一个启动的模块，集成了一般翻译器的反汇编和运行环境模拟等基本功能。如果发现内核API调用，将执行权限交给host OS。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.7.png?raw=true)  


#### 5.2. 外部函数直接执行机制

顾名思义，此机制监控所有target程序的跳转指令的目标地址，如果目标地址是第三方库，则修改PC，直接执行第三方库函数，不用翻译。当然不仅限于第三方库，可以扩展至所有现成的代码。

### 6. 面向loongson的KBT性能优化策略

#### 6.1. 硬件模拟方式优化

硬件设备往往独立于CPU体系结构，loongson上的外设与x86上的相同，故target可以直接用这类硬件，而不用纯软件模拟。

理想情况下，DBT系统只负责模拟一个CPU以及与CPU紧密耦合的部分核心硬件，其他外设通过特殊方法直接利用host外设。

#### 6.2. 基于KBT的管道式硬件模拟

通过管道式硬件模拟是DBT系统中运行的target OS能够直接识别出loongson主板上插入的PCI硬件设备。

该技术原理如下：

在DBT系统虚拟的PCI总线上增加虚拟设备，设定其PCI的配置空间的内容与实际PCI设备相同。包括设备类型、存储空间大小、中断号大小等。因此在target OS做PCI扫描时，能够自动检测到这样的PCI设备。这样完成了物理外设在DBT系统虚拟PCI总线上的挂载。当系统中的设备驱动程序向PCI设备发送请求时，由DBT系统接管并传递到实际的PCI设备。管道负责将target应用程序对硬件设备的访问信息传递给真实的host硬件。

![](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/9.8.png?raw=true)  


### 7. 思考

7.1. 应该设计准确的信息统计系统，用来统计执行情况，从而根据这些执行情况指导优化方向。

7.2. 文章设计的翻译系统和现在接触的xqm不一样，它解决的问题是需要用到部分内核模块，如驱动等的程序，但传统的应用级翻译系统无法直接翻译执行OS内核中的模块，只有系统级翻译系统才能做到。而实现系统级翻译器很复杂，故将翻译器的一部分实现在target内核，这可以理解为“半虚拟化”，而且这种做法只有自己开发OS才能实现。问题是现在没有接触过系统级翻译器，不能完全理解这种设计。而且虽然知道学过OS，知道OS有不同的执行模式，但这都是概念上的认识，缺乏实际的认识。要如何加强系统方面的了解。

7.3. 开发xqm会应用在公司的系统上么，文章中提到“龙芯二进制翻译系统”应该不是xqm，那xqm是用来作为增强我们对系统认识、开发经验的试验型项目么。