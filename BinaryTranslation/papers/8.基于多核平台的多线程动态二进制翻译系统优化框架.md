## 基于多核平台的多线程动态二进制翻译系统优化框架

### 1. 相关背景

#### 1.1. 系统设计思路

将原有动态二进制翻译系统重新划分为多线程架构：主线程负责基本块的翻译、代码块的执行和链接；优化子线程负责超级块的生成、翻译和链接，并利用多核处理器结合多线程执行的优点获得性能加速。

#### 1.2. 早期多线程翻译模型存在的问题

（1）**翻译模块的本身开销不足以实现为线程**。如果线程本身的开销并不能够占到原有执行总开销的较大比例，使用多线程技术获得的并行优势反而会少于额外开销对系统带来的负担。

（2）翻译预测实现的困难性。

（3）多个线程调度和管理的困难性。这个是最大的问题。

### 2. 引入多线程优化的挑战

#### 2.1. 多线程优化算法的选取依据

超级块生成算法不仅**本身具有相对较高的开销**，而且超级块优化的质量对系统性能的影响远大于基本块质量对系统性能的影响，同时，生成超级块和执行基本块两个过程可以**同时进行**。因此，超级块的生成算法可以使用多线程优化的思想实现。

#### 2.2. 使用多线程生成超级块的挑战

（1）软件缓存的划分和冲突解决。CrossBit原有架构使用唯一的缓存架构同时存放基本块和超级块，但是如果采用多线程并行生成基本块和超级块时，就存在生成的**超级块覆盖了原有的基本块**的情况，造成程序执行的异常。同时，由于翻译代码的长度是在翻译工作完成时得到的，超级块的翻译和基本块的翻译如果同时进行，则无法根据代码块长度合理分配。所以无法提前划分空间存储。

（2）参数传递。超级块的检测是通过收集剖分信息的过程完成的，由于热路径上的基本块的执行速度快且执行频率高，如何将起始参数传递给优化线程是一个需要解决的问题（不懂）。

（3）超级块链接。当超级块使用线程生成以后，超级块链接的同时，执行模块可能还在对基本块进行修改，造成冲突。

（4）线程间的同步。由于优化线程和其他模块之间还是会有少量的交互问题，线程间的同步操作仍然需要。

#### 2.3. 多核多线程编程技术的关键点

尽管多线程编程技术可以提高程序的性能，但是并不是所有的程序都适用该技术，如果不注意以下关键点，很有可能多线程化后反而会降低程序的性能。

（1）测量系统的开销比情况。

（2）考虑不同核心的缓存联合问题。

（3）不要创建过多的线程。过多的线程会增加处理器线程调度的开销，同时会增加锁算法设计的难度，导致线程间同步的结果不可预测，特别是容易出现核心线程始终得不到处理器调度的情况。

（4）避免使用全局的锁和数据结构。

（5）多线程中避免过多的内存分配和释放操作。多线程程序难免出现大量使用堆的操作，堆的分配和释放通常由底层系统调用完成，在多线程环境下，底层系统调用也会加锁保护这部分操作的顺序性。如果大量的分配和释放，会占用大量同步时间，因此较好的策略是预先申请大段空间，在线程执行时私有分配和释放，线程运行结束后统一释放，而不是通过系统调用完成。

（6）多核处理器的硬软亲和力的选择。亲和力是多核处理器平台下的多线程程序所特有的一个属性，即该线程具体工作在多核处理器的哪个核心上。软亲和力是指该属性由操作系统**随机生成**，而硬亲和力是指该属性由**软件自身设定**。

### 3. MTCrossBit 系统架构

![img](https://github.com/UtopianFuture/UtopianFuture.github.io/blob/master/image/8.1.png?raw=true)  


#### 3.1. MTCrossBit 的工作流程如下：

（1）创建优化子线程，设置线程属性，初始化动态二进制翻译系统各模块。根据线程个数不是越多越好的原则，优化子线程仅设置一条，并进行轮询式优化。

（2）加载器(Image Loader)加载需要翻译的整个映像文件至内存中。

（3）创建线程间通信使用的队列，用于线程间的参数传递。

（4）基本块翻译模块开始运行，翻译生成基本块并将该基本块存放入软件缓存中，更新哈希表的对应项。

（5）执行模块首先尝试加锁，加锁成功后开始执行翻译好后的基本块，并通过profiling来判断当前执行的基本块是否为一个热点。

（6）当剖分指令检测到热点存在时，执行模块使用 ASLC 机制(Assembly Language Level Communication)，将热点信息传入之前创建的通信队列中。

（7）优化子线程通过对队列的访问获取热点信息，启动超级块生成算法。这里需要**与主执行模块抢占加锁**，因为访问的是相同的基本块，但这样就变成了串行执行。另一种处理方法是使用**物理拷贝**的方式，即通过空间来换取时间的方法，如上图所示，将单目标代码缓存转换为多级缓存，这样就可以解决原先的冲突问题。

（8）生成的超级中间代码块可以继续传递给下一层线程，利用多线程优化并行计算的优势，生成更优的超级块，并链接和存入上图的第三个缓存中。

#### 3.2. MTCrossBit 的缺点分析

（1）多线程优化技术现阶段多用于学术和理论界的研究中，并没有被工业界采用，原因就是多线程优化在实际的操作系统中**无法保证多条线程都可以被实时调度**，当某条线程因为没有处理器资源使用而处于阻塞态时，就会影响整个系统的性能。

（2）MTCrossBit 中，超级块的链接操作与主线程的执行模块之间存在冲突的可能。

### 4. 思考

4.1. 传统的超级块构建是怎么样的？不是说动静结合么，静态的优化，那对性能影响应该不大。考虑到实现很慢发，这个方法总的来说没有动静结合可行性高。

4.2. 多线程执行的思路可以认真考虑以下，结合流水线的思想：一个线程反汇编，一个线程翻译，一个线程编译，然后优化是静态的。