## 动态二进制翻译系统中浮点运算单元研究

浮点指令x87, sse部分还不是很熟，看不太懂，故只记录寄存器分配算法。

### 1. 混合式浮点运算单元

### 2. 寄存器分配算法

#### 2.1. 简单寄存器分配算法

给每个目标寄存器编号，当有目标寄存器作为牺牲寄存器的时候，记录该目标寄存器的编号，当下一次需要找牺牲寄存器时，则从该编号的下一位置搜索。

#### 2.2. 全局寄存器分配算法

首先找出基本块内使用频率最高的虚拟寄存器，然后给该虚拟寄存器指定一个固定的目标寄存器，从剩余的目标寄存器挑选一个合适的分配给其他需要使用目标寄存器的虚拟寄存器。其与简单寄存器分配算法区别在于**用于全局寄存器的目标寄存器不再参与目标寄存器的换入换出**。

#### 2.3. Next-Use寄存器分配算法

基于 Next-Use 信息进行寄存器分配的算法，在使用之前先扫描整个基本块，收集整个基本块内虚拟寄存器的 Next-Use 信息。**Next-Use** **信息是指虚拟寄存器下次被使用的位置信息，**由虚拟寄存器和虚拟寄存器所在位置组成（可以理解为保存之后有可能使用的寄存器，防止抖动）。

在有空闲目标寄存器的时候，该算法选择一个目标寄存器给虚拟寄存器。当没有空闲目标寄存器时，选择 **Next-Use** **信息值最大的虚拟寄存器（即最近最不可能使用到的寄存器）**，把其内容从对应的目标寄存器换入到内存，然后分配该目标寄存器给需要的虚拟寄存器。

#### 2.4. 简化的图染色寄存器分配算法

图染色算法是将分配范围内的变量看成一个个节点，然后在存活期重叠的节点之间连接一条边，这样所有节点组成了一张干扰图，干扰图里相邻的两个节点不能分配给同一个寄存器。

在图染色寄存器分配算法中，干扰图的构建是整个算法最耗时的部分，从时间复杂度上看，最坏情况下是O(n ^2 )，n是存活期的数目。因此，**精简干扰图的构建**能够避免引入过多的开销，同时利用图染色算法高效的分配结果。

该算法构建干扰图一次，并且去除了结合，冷冻等图染色算法用到的技术。整个算法首先扫描基本块，收集干扰信息，构建干扰图，然后基于干扰图对虚拟寄存器进行寄存器预分配。

### 3. 思考

在xqm中，寄存器分配算法是这样的：

部分虚拟寄存器已经分配了物理寄存器。新的tb会首先遍历已经分配了的寄存器，如果没有空闲的物理寄存器可分配，就将该tb剩余的itemp reg全遍历一遍，放到内存指定区域，记录virtual id。之后遍历已经分配了物理寄存器的虚拟寄存器（最多6个），如果这6个寄存器在该tb中没有用过，则为dead virtual id，需要清除。清除后再将其分配给当前需要分配的virtual id。遍历已经分配过的虚拟寄存器在该tb中是否出现过是为了不出现reg抖动。

**存在的问题：**

那如果已经分配过的虚拟寄存器在该tb中都出现过，就不能空出寄存器槽，岂不是分配失败？